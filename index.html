<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Failing for the right reasons</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <style>
        .fresho-logo img {
            width: 80px;
            border-style: none !important;
            box-shadow: none !important;
            margin: 0px 0px -30px !important;
        }
        .fresho-logo span {
            padding-left: 10px;
        }
        .twitter-avatar {
            border-radius: 50px;
            border: 1px solid #fff !important;
            width: 80px !important;
            margin: 0px 0px -30px !important;
        }

        .reveal .fake-game {
            background-color: #ddd;
            width: 90%;
            margin: 20px auto;
        }

        .reveal .fake-game-nav {
            background-color: #1b91ff;
        }

        .reveal .fake-game-status {
            text-align: left;
            width: 90%;
            margin: 20px auto;
        }

        .reveal .fake-game-main {
            display: flex;
            flex-direction: row;
            width: 90%;
            margin: 20px auto;
        }

        .reveal .fake-game-row {
            display: flex;
            flex-direction: row;
        }

        .reveal .fake-game-image {
            background-color: #ccc;
            width: 2em;
            height: 2em;
            border: none;
            margin: 5px 5px 0 0;
        }

        .reveal .fake-game-guess-container {
            width: 50%;
        }

        .reveal .fake-game-guess-container textarea {
            font-size: 1em;
        }

        .reveal .fake-game-guess {
            width: 100%;
            height: 100%;
        }

        .reveal .fake-game ul {
            list-style: none;
        }

        .reveal .slides > section, .reveal .slides > section > section {
            padding: 0px;
        }

        h4.code-snippet-title {
            text-align: left;
            width: 90%;
            margin: 20px auto;
        }

        .what-is-the-app-image-area {
            width: 75%;
            margin: auto !important;
        }

        .iterative-testing {
            width: 50%;
            margin: auto !important;
        }

        .failing-span {
            background-color: #f2dede;
            border-color: #ebcccc;
            color: #a94442;
            border-radius: .25rem;
        }

        .passing-span {
            background-color: #dff0d8;
            border-color: #d0e9c6;
            color: #3c763d;
            border-radius: .25rem;
        }
        .iteration-span {
            background-color: #d9edf7;
            border-color: #bcdff1;
            color: #31708f;
            border-radius: .25rem;
        }
        .reveal pre.code-100 {
          width: 100%;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Failing for the REACT reason</h1>
            <h3>Selena Small & Michael Milewski</h3>
            <aside class="notes" data-markdown>
              We work at Fresho!

              And at Fresho! we're 100% focused on multi layer outside in BDD

              Sound boring?

              Yeah, it's not.

              Ok we've only got 10 minutes so let's make sure everyone knows what we mean by 100% MULTI-LAYER OUTSIDE-IN
            </aside>
        </section>

        <!-- How Flows/Mechanics fit into testing -->
        <section>
            <img src="images/units/11-api-acceptance.jpg" width="600" height="600">
            <aside class="notes" data-markdown>
                Here's an example of a back end might look, we have a number of tests around individual
                models, controllers, service objects as well as integration tests around groups of these
                that work together

                You guys don't really care about that though so we won't bother talking about it

                But at the highest level of backend tests, we treat the API as a unit and do a full
                integration test to essentially test the back end as a whole

                We'll leave it at that 'cause we don't want to bore you
            </aside>
        </section>

        <section>
            <img src="images/units/12-spa.jpg" width="600" height="600">
            <aside class="notes" data-markdown>
                In this app, our frontend is a SPA - you all know what that is. A single page application

                Which as you know is made up of a number of components

                Now, we thought about writing this in Ember - like we do at Fresho! - but since we're at a React
                meetup that didn't seem appropriate
            </aside>
        </section>

        <section>
            <img src="images/units/13-fe-component.jpg" width="600" height="600">
            <aside class="notes" data-markdown>
                So anyway, each frontend component will be tested in isolation

                Anyone have thoughts on isolated component tests in React?

                What about snapshot testing?
            </aside>
        </section>

        <section>
            <img src="images/units/SPA-mechanic.jpg" width="600" height="600">
            <aside class="notes" data-markdown>
                - Now we move on to testing the users experience of the app.
                - The example we will show you today is basically a flow through 3 pages.
                - We want to test that each of those pages individually
                - if you imagine a multi page form wizard, we want to be able to test any one of
                those steps in isolation from each other
                - we call this style of integration test a Mechanic test that exercises
                the "Mechanics" of the page
            </aside>
        </section>

        <section>
            <img src="images/units/SPA-flow.jpg" width="600" height="600">
            <aside class="notes" data-markdown>
                - finally the highest level of tests are what we call "integration lifecycle flows" or simply "flows"
                - We test the flow on effects of user interactions between frontend components and pages
                - As you can see here, this style of test tests the whole application
                - Back end, API and Front end!
                - They encapsulate user behaviour and interactions with the whole system
            </aside>
        </section>

        <section>
            <h1>Flows</h1>

            <aside class="notes" data-markdown>
                * joke about being rails devs
                * joke about rails backend instead of node

                - Every piece of code we write starts with a series of full integration tests
                - let's start writing some code
                - yep

            </aside>
        </section>

        <!-- # Submit a guess (Failing Flow) -->
        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                feature 'Game play lifecycle', js: true do
                  scenario 'WINNING a game' do
                    Given <mark> 'Game is setup with names of cute animals'</mark> do
                      ["paddy melon", "beaver"].each do |phrase|
                        Term.<mark>create(phrase: phrase)</mark>
                      end
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                - we have setup a flow using ruby RSpec, capybara and selenium testing frameworks
                - The feature we are building is a Game play lifecycle flow
                - our first scenario is Winning the game
                - and we setup some initial state for our Game with names of cute animals
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                feature 'Game play lifecycle', js: true do
                  <mark>context</mark> 'Game is setup with spooky terms' do
                    before do
                      ["ghost", "haunted house"].each do |phrase|
                        Term.<mark>create(phrase: phrase)</mark>
                      end

                      scenario 'WINNING a game' do
                      end
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                - the game setup can be re-written as a "context" of this particular test
                - joke about context
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                feature 'Game play lifecycle', js: true do
                  context 'Game is setup with spooky terms' do
                    before do ... end

                    scenario 'WINNING a game' do
                      When 'user starts the game' do
                        visit('/')
                        wait_for {
                          <mark>focus_on(:welcome).text</mark>
                        }.to eq('Welcome to the Game')
                      end
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                - 2 simple steps
                - visit the app
                - confirm you are there
                - This is the first piece of code in the whole app!
                - No controllers, models, views. No migrations or db entries
                - The first piece of code is always a test.
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.1-home-empty.png" />
            </div>
            <aside class="notes" data-markdown>
                - And when we run that test, what's going to happen?
                - Well, it's going to fail! Of course
            </aside>
        </section>

        <section>
            <h3>Render images <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.2-welcome.png" />
            </div>
            <pre><code data-trim>
                import React from 'react'

                export default () => (
                  <div>
                    <h1>Welcome to the Game</h1>
                  </div>
                )
            </code></pre>
            <aside class="notes" data-markdown>
                - a simple react component to spit a H1 on the page
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'user starts the game' do
                  visit('/')
                  wait_for {
                    focus_on(:welcome).text
                    }.to eq('Welcome to the Game')

                  <mark>focus_on(:welcome).start_game</mark>
                end

                Then 'the game commences' do
                  pending 'start game button doesnt start a game!'
                  wait_for { focus_on(:game).round }.to eq('1')
                end
            </code></pre>
            <aside class="notes" data-markdown>
                - back to the test
                - now we want to focus_on welcome start_game
                - which uses a page fragment to click on the "start game" button
                - the button? what button
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.2-welcome.png" />
            </div>
            <aside class="notes" data-markdown>
                - there is no button!
                - no shit
                - oh yeah
                - fail first
            </aside>
        </section>

        <section>
            <h3>Render images <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.3-click-start.gif" width="400" />
            </div>
            <pre><code data-trim>
                import React from 'react'
                import { Link } from 'react-router-dom'

                export default () => (
                  <div>
                    <h1>Welcome to the Game</h1>
                    <Link to="/round/1">Start Game</Link>
                  </div>
                )
            </code></pre>
            <aside class="notes" data-markdown>
                - lets create one
                - using react router, we Link to the first round
                - is this good react
                - look a room full of no reaction
                - maybe they are ember devs after all
                - cmon people React
                - where are the tests?
                - for react?
                - fuck em just snap shot test
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'user starts the game' do
                  visit('/')
                  wait_for {
                    focus_on(:welcome).text
                  }.to eq('Welcome to the Game')

                  focus_on(:welcome).start_game
                end

                Then 'the game commences' do
                  <mark>wait_for { focus_on(:game).title }.to eq('1')</mark>
                end
            </code></pre>
            <aside class="notes" data-markdown>
                - How do we know the game has commenced?
                - we are on round 1, it says it in the title
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.4-round-empty.png" />
            </div>
            <aside class="notes" data-markdown>
                - and we get nothing
                - zip
            </aside>
        </section>

        <section>
            <h3>Render images <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.5-navigate-to-round-1-text.gif" width="400" />
            </div>
            <pre><code data-trim>
                ...
                  this.state = { round: parseInt(props.match.params.round, 10) }
                ...

                render = () => (
                  <div>
                    <h1>Round <span className="round">{this.state.round}</span></h1>
                    <Link to="/round/1">Start Game</Link>
                  </div>
                )
            </code></pre>
            <aside class="notes" data-markdown>
                - here is a Rounds component in React
                - it gets the React Router round parameter from the path and displays it
                - should we be doing something different with state? audience?
                - come grab us later to tell us, PR's on the github will also be accepted.
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'user starts the game' do
                  visit('/')
                  wait_for {
                    focus_on(:welcome).text
                  }.to eq('Welcome to the Game')

                  focus_on(:welcome).start_game
                end

                Then 'the game commences' do
                  wait_for { focus_on(:game).round }.to eq('1')
                  <mark>wait_for { focus_on(:game).images.count }.to eq(9)</mark>
                end
            </code></pre>
            <aside class="notes" data-markdown>
                - back in flow test land
                - we are now waiting on 9 images
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.6-no-images.png" />
            </div>
            <aside class="notes" data-markdown>
                - images? what of those cute furry animals?
                - there are none
                - good! [pause] a failing test
            </aside>
        </section>

        <section>
            <h3>Render images <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.7-navigate-to-round-1-text-and-images.gif"  width="400" />
            </div>
            <pre><code data-trim>
                <div className="images-container">
                  API.fetchRoundData(round).then((data) => {
                    this.setState(data)
                ...
                  { this.state.images.map( ({id, src}) => (
                    <img key={id} src={src} alt="nice try"/>
                  ))}
                </div>
            </code></pre>
            <aside class="notes" data-markdown>
                - there is more code here
                - like API endpoints, controllers
                - models, serializers
                - but you guys don't care, you are react developers so here is a snippet of some JSX instead
            </aside>
        </section>

        <section>
            <h3>Render images <span class="iteration-span">Iteration 1</span></h3>
            <pre><code data-trim data-noescape style="max-height: 500px">
                feature 'Game play lifecycle', js: true do
                  context 'Game is setup with spooky terms' do
                    before do
                      ["ghost", "haunted house"].each do |phrase|
                        Term.create(phrase: phrase)
                      end
                    end

                    scenario 'WINNING a game' do
                      When 'user starts the game' do
                        visit('/')
                        wait_for {
                          focus_on(:welcome).text
                        }.to eq('Welcome to the Game')

                        focus_on(:welcome).start_game
                      end

                      Then 'the game commences' do
                        wait_for { focus_on(:game).round }.to eq('1')
                        wait_for { focus_on(:game).images.count }.to eq('9')
                      end
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                - wrapping up iteration 1 we have just written
                - we have a WHEN action on the system
                - and THEN a measurable state showing the commencement of the game
            </aside>
        </section>

        <section>
            <h3>Submit a guess <span class="failing-span">Failing test</span></h3>
            <div style="display: flex">
            <pre><code data-trim data-noescape style="max-height: 500px">
                When 'user starts the game' do
                  visit('/')
                  wait_for {
                    focus_on(:welcome).text
                  }.to eq('Welcome to the Game')

                  focus_on(:welcome).start_game
                end

                Then 'the game commences' do
                  wait_for { focus_on(:game).round }.to eq('1')
                  <mark>wait_for { focus_on(:game).status }.to eq('IN-PROGRESS')</mark>
                  wait_for { focus_on(:game).images.count }.to eq(9)
                end
            </code></pre>
            </div>
            <aside class="notes" data-markdown>
                - dealing with us backend devs is a pain
                - there is all this latency, network to and fro
                - great time for spinners
                - or in our case a state of LOADING and game IN-PROGRESS
                - This is where page mechanics come in
                - not wanting to start the game each time, we just want to explore the mechanics
                of the status component on this page
            </aside>
        </section>

        <section>
            <h3>failing mechanic TODO</h3>
            <h3>lIVE CODING</h3>
            <aside class="notes" data-markdown></aside>
        </section>
        <section>
            <h3>component test TODO</h3>
            <aside class="notes" data-markdown></aside>
        </section>
        <section>
            <h3>frontend impmentation TODO</h3>
            <aside class="notes" data-markdown></aside>
        </section>
        <section>
            <h3>back to the compelte flow TODO</h3>
            <aside class="notes" data-markdown></aside>
        </section>

        <!-- # Play the game! -->
        <section>
            <h3>Let's play!</h3>
            <div>Just cause we built it, lets play a game!</div>

            <aside class="notes" data-markdown>
                - Aaaaand, just cause we built
                - let's play the game.
                - Who wants to play?!
            </aside>
        </section>

        <section>
          <iframe src="https://search-term.herokuapp.com" width="600" height="600"></iframe>
        </section>

        <!-- # Thanks -->
        <section>
            <h3>Resources</h3>
                <p><a href="https://failure-driven.com/">https://failure-driven.com/</a></p>
                <p><a href="https://fresho.com/" class="fresho-logo"><img src="images/fresho_logo_green.svg"/><span>https://fresho.com/</span></a></p>
            <div>
                <a href="http://twitter.com/intent/user?screen_name=selenasmall88">
                    <img class="twitter-avatar" src="images/avatar-selena.jpg" alt="selena-small"/>
                    <span>@selenasmall88</span>
                </a>
            </div>
            <div>
                <a href="http://twitter.com/intent/user?screen_name=saramic">
                    <img class="twitter-avatar" src="images/avatar-michael.jpg" alt="michael-milewski"/>
                    <span>@saramic</span>
                </a>
            </div>

            <aside class="notes" data-markdown>
                - go checkout our blog Failure Drivem
                - you will find links to the game, the code and this presentation
                - we work for Fresho!
                - catch us on twitter
                - any react tips, tweet them at us
                - come over and give us 5 minutes, we will take an hour
                - Thanks everyone!
            </aside>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ],
    transition: 'none',
    history: true,
  });
</script>
</body>
</html>
