<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Failing for the right reasons</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <style>
        .twitter-avatar {
            border-radius: 50px;
            border: 1px solid #fff !important;
            width: 80px !important;
            margin: 0px 0px -30px !important;
        }

        .reveal .fake-game {
            background-color: #ddd;
            width: 90%;
            margin: 20px auto;
        }

        .reveal .fake-game-nav {
            background-color: #1b91ff;
        }

        .reveal .fake-game-status {
            text-align: left;
            width: 90%;
            margin: 20px auto;
        }

        .reveal .fake-game-main {
            display: flex;
            flex-direction: row;
            width: 90%;
            margin: 20px auto;
        }

        .reveal .fake-game-row {
            display: flex;
            flex-direction: row;
        }

        .reveal .fake-game-image {
            background-color: #ccc;
            width: 2em;
            height: 2em;
            border: none;
            margin: 5px 5px 0 0;
        }

        .reveal .fake-game-guess-container {
            width: 50%;
        }

        .reveal .fake-game-guess-container textarea {
            font-size: 1em;
        }

        .reveal .fake-game-guess {
            width: 100%;
            height: 100%;
        }

        .reveal .fake-game ul {
            list-style: none;
        }

        .reveal .slides > section, .reveal .slides > section > section {
            padding: 0px;
        }

        h4.code-snippet-title {
            text-align: left;
            width: 90%;
            margin: 20px auto;
        }

        .what-is-the-app-image-area {
            width: 75%;
            margin: auto !important;
        }

        .iterative-testing {
            width: 50%;
            margin: auto !important;
        }

        .failing-span {
            background-color: #f2dede;
            border-color: #ebcccc;
            color: #a94442;
            border-radius: .25rem;
        }

        .passing-span {
            background-color: #dff0d8;
            border-color: #d0e9c6;
            color: #3c763d;
            border-radius: .25rem;
        }
        .iteration-span {
            background-color: #d9edf7;
            border-color: #bcdff1;
            color: #31708f;
            border-radius: .25rem;
        }
        .reveal pre.code-100 {
          width: 100%;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Failing for the right reason</h1>
            <h3>Selena Small & Michael Milewski</h3>
            <aside class="notes" data-markdown>
              #### Selena: intro

              #### Michael: **runs on side stage**
                - Idea for app
                - Big - break internet
                - Game - Images - Scoreboard
                - Web - Share Score

              *Selena*: No. The first line of code you write is a test
            </aside>
        </section>

        <section>
            <h3>What is the app?</h3>
            <aside class="notes" data-markdown>
              * Selena: Who uses it? What kind of person is going to play this game?

              * Michael: Halloween, Casper
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-1-enter-url.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper visits SearchTerm
                -
                -
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Selena: ah! so When casper visits the game, lets call it SearchTerm - then what?

                * Michael: greeted with a logo, welcome message
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-2-welcome-text.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper visits SearchTerm
                - <mark>Then a welcome message is shown</mark>
                -
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Selena: A welcome message? kind of like this?
                          How does the game start?

                * Michael: oh a button
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-3-start-button.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper visits SearchTerm
                - Then a welcome message is rendered
                - <mark>And a start game button is rendered</mark>
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Selena: Right, so when Casper clicks the start button
                          Then the game starts?

                * Michael: yup you are in the game
            </aside>
        </section>

        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-4-click-start-button.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper starts the game
                -
                -
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Selena: How do you know that the game has started?

                * Michael: ding ding, round 1 baby
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-5-round-1.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper starts the game
                - <mark>Then round 1 begins</mark>
                -
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Selena: Now are you getting? you keeping up?

                ** Michael takes over explaining **
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-6-images.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper starts the game
                - Then round 1 begins
                - <mark>And 9 images are displayed</mark>
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael:
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-7-text-area-.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper starts the game
                - Then round 1 begins
                - And 9 images are displayed
                - <mark>And a text area is rendered</mark>
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael:
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-8-timer.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper starts the game
                - Then round 1 begins
                - And 9 images are displayed
                - And a text area is rendered
                - <mark>And a countdown timer is rendered</mark>
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael:
            </aside>
        </section>

        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-9-status.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When the game is In-progress
                -
                -
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael:
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-10-counting-down.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When the game is In-progress
                - <mark>Then the countdown timer starts counting down</mark>
                -
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael:
            </aside>
        </section>

        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-11-guess.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper guesses the search term used to find these images
                -
                -
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael:
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-12-timer-stops.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper guesses the search term used to find these images
                - <mark>Then the countdown timer stops</mark>
                -
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael:
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-13-score.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper types the correct guess into the text box
                - Then the countdown timer stops
                - <mark>And a score is rendered for the round</mark>
                -
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael:
            </aside>
        </section>
        <section>
            <div class="what-is-the-app-image-area">
                <img src="images/app-14-winner.png" style="" />
            </div>

            <pre class="code-100"><code data-trim data-noescape>
                - When Casper types the correct guess into the text box
                - Then the countdown timer stops
                - And a score is rendered for the round
                - <mark>And a winner message is rendered</mark>
                -
            </code></pre>
            <aside class="notes" data-markdown>
                * Michael: so how does this all hang together Selena?
            </aside>
        </section>

        <section>
            <pre><code data-trim data-noescape style="max-height: 600px">
                When Casper visits SearchTerm

                Then a welcome message is rendered
                  And a start game button is rendered

                When Casper starts the game

                Then round 1 begins
                  And 9 images are displayed
                  And a text area is rendered
                  And a countdown timer is rendered

                When the game is In-progress

                Then the countdown timer starts counting down

                When Casper types the correct guess into the text box

                Then the countdown timer stops
                  And a score is rendered for the round
                  And a winner message is rendered
            </code></pre>
            <aside class="notes" data-markdown>
                * Selena:
                  * GIVEN the state of the world before you begin
                  * WHEN an action is carried out
                  * THEN observable changes are expected
            </aside>
        </section>

        <!-- # TODO Michael analogy of why testing matters -->
        <section>
            <h3>Why testing matters</h3>
            <ul>
              <li class="fragment"><img src="images/rachet_and_prawl.jpg" /></li>
              <li class="fragment">incremental iterative development</li>
            </ul>
            <aside class="notes" data-markdown>
                * Michael:
                  1. scary writing code, nothing to catch you
                  2. bring in the ratchet
                  3. bit by bit you can move forward
                  4. takeaway Incremental iterative development

                * Selena: I'm not quite sure everyone's following...
                          Let's run through an example
            </aside>
        </section>

        <!-- # TODO 3 basic iterations building out the code -->
        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                feature 'Game play lifecycle', js: true do
                  scenario 'WINNING a game' do
                    When 'user starts the game' do
                      visit('/')
                      wait_for {
                        <mark>focus_on(:welcome).text</mark>
                      }.to eq('Welcome to the Game')
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: 2 simple steps visit and confirm you are there

                *Selena: This is the first piece of code in the whole app!
                         No controllers, models, views
                         No migrations or db entries
                         The first piece of code is always a test.
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.1-home-empty.png" />
            </div>
            <aside class="notes" data-markdown>
                - And when we run that test, what's going to happen?
                - Well, it's going to fail! Of course
            </aside>
        </section>

        <section>
            <h3>Render images <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.2-welcome.png" />
            </div>
            <pre><code data-trim>
                import React from 'react'

                export default () => (
                  <div>
                    <h1>Welcome to the Game</h1>
                  </div>
                )
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: a simple react component to spit a H1 on the page
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'user starts the game' do
                  visit('/')
                  wait_for {
                    focus_on(:welcome).text
                    }.to eq('Welcome to the Game')

                  <mark>focus_on(:welcome).start_game</mark>
                end

                Then 'the game commences' do
                  pending 'start game button doesnt start a game!'
                  wait_for { focus_on(:game).round }.to eq('1')
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: now we want to focus_on welcome start_game

                *Selena: What is focus_on?
                    We've hidden away code that asserts against html
                    in order to make these high level flows easier to read.
            </aside>
        </section>

        <section>
            <h3>Page Fragment</h3>
            <pre><code data-trim data-noescape>
                module PageFragments
                  module Welcome
                    def text
                      browser.find('h1').text
                    end

                    def start_game
                      browser.click_on('Start Game')
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Selena: As you can see this particular fragment finds the text inside a div with class `WELCOME`
                    One benefit of separating out fragments like this, is that
                    they're reusable throughout the tests.
                    - if a class name changes in the html, you don't have to trawl through
                      your tests to change every assertion. You can just change it here
                    - Ans as I mentioned, your tests also become much more readable
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'user starts the game' do
                  visit('/')
                  wait_for {
                    focus_on(:welcome).text
                    }.to eq('Welcome to the Game')

                  <mark>focus_on(:welcome).start_game</mark>
                end

                Then 'the game commences' do
                  pending 'start game button doesnt start a game!'
                  wait_for { focus_on(:game).round }.to eq('1')
                end
            </code></pre>
            <aside class="notes">
                *Michael:

                *Selena: What is focus_on?
                    We've hidden away code that asserts against html
                    in order to make these high level flows easier to read.
            </aside>
        </section>


        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.2-welcome.png" />
            </div>
            <aside class="notes" data-markdown>
                *Michael: and the app is failing as we have not built this
            </aside>
        </section>

        <section>
            <h3>Render images <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.3-click-start.gif" width="400" />
            </div>
            <pre><code data-trim>
                import React from 'react'
                import { Link } from 'react-router-dom'

                export default () => (
                  <div>
                    <h1>Welcome to the Game</h1>
                    <Link to="/round/1">Start Game</Link>
                  </div>
                )
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: and using react router we Link to the first round
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'user starts the game' do
                  visit('/')
                  wait_for {
                    focus_on(:welcome).text
                  }.to eq('Welcome to the Game')

                  focus_on(:welcome).start_game
                end

                Then 'the game commences' do
                  <mark>wait_for { focus_on(:game).round }.to eq('1')</mark>
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: How do we know we are on the first round? a round title including 1
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.4-round-empty.png" />
            </div>
            <aside class="notes" data-markdown>
                *Michael: got nothing

                *Selena: questions around fail in round 1
                Route not there
                Second page doesn't load
                Lower level tests?
            </aside>
        </section>

        <section>
            <h3>Render images <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.5-navigate-to-round-1-text.gif" width="400" />
            </div>
            <pre><code data-trim>
                ...
                  this.state = { round: parseInt(props.match.params.round, 10) }
                ...

                render = () => (
                  <div>
                    <h1>Round <span className="round">{this.state.round}</span></h1>
                    <Link to="/round/1">Start Game</Link>
                  </div>
                )
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: a round component in React which gets the round parameter from the path and displays it
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'user starts the game' do
                  visit('/')
                  wait_for {
                    focus_on(:welcome).text
                  }.to eq('Welcome to the Game')

                  focus_on(:welcome).start_game
                end

                Then 'the game commences' do
                  wait_for { focus_on(:game).round }.to eq('1')
                  <mark>wait_for { focus_on(:game).images.count }.to eq(9)</mark>
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: again we back ourselves up with a failing test, for 9 images ...
            </aside>
        </section>

        <section>
            <h3>Render images <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.6-no-images.png" />
            </div>
            <aside class="notes" data-markdown>
                *Michael: ... that are not there
            </aside>
        </section>

        <section>
            <h3>Render images <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-1.7-navigate-to-round-1-text-and-images.gif"  width="400" />
            </div>
            <pre><code data-trim>
                <div className="images-container">
                  API.fetchRoundData(round).then((data) => {
                    this.setState(data)
                ...
                  { this.state.images.map( ({id, src}) => (
                    <img key={id} src={src} alt="nice try"/>
                  ))}
                </div>
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: and to make it pass we make an API call -> API endpoint -> controller -> model -> json back

                *Selena:
                  - there is a few things going on, rendering, waiting for images, changes in the DOM
                  - these can lead to flakey behaviour, things that fail every now and again
                  - this is NOT good for testing, we want to avoid elements moving around
            </aside>
        </section>

        <section>
          <h3>Flake due to image loading</h3>
          <img src="images/flakey_fresho_header.gif" />
        </section>

        <section>
            <h3>Render images <span class="iteration-span">Iteration 1</span></h3>
            <pre><code data-trim data-noescape style="max-height: 500px">
                feature 'Game play lifecycle', js: true do
                  scenario 'WINNING a game' do
                    When 'user starts the game' do
                      visit('/')
                      wait_for {
                        focus_on(:welcome).text
                      }.to eq('Welcome to the Game')

                      focus_on(:welcome).start_game
                    end

                    Then 'the game commences' do
                      wait_for { focus_on(:game).round }.to eq('1')
                      wait_for { focus_on(:game).images.count }.to eq('9')
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: wrap up iteration 1

                *Selena: On the next iteration, we have a lot of the context already set up.
                    Adding the next feature (Submit a guess) is now fairly straight forward
            </aside>
        </section>

        <section>
            <h3>Submit a guess <span class="failing-span">Failing test</span></h3>
            <div style="display: flex">
            <pre><code data-trim data-noescape style="max-height: 500px">
                feature 'Game play lifecycle', js: true do
                  scenario 'WINNING a game' do
                    When 'user starts the game' do
                      visit('/')
                      wait_for {
                        focus_on(:welcome).text
                      }.to eq('Welcome to the Game')

                      focus_on(:welcome).start_game
                    end

                    Then 'the game commences' do
                      wait_for { focus_on(:game).round }.to eq('1')
                      <mark>wait_for { focus_on(:game).status }.to eq('IN-PROGRESS')</mark>
                      wait_for { focus_on(:game).images.count }.to eq(9)
                    end
                  end
                end
            </code></pre>
            </div>
            <aside class="notes" data-markdown>
                *Michael: more state in-progress loading etc

                *Selena: Mechanics
                    - This is where mechanics come in

                    - The style of test we've been writing here is an integration test
                    - At Fresho we organise these type of tests into two categories - flows and mechanics
                    - Flows, like we're writing here test the users experience of flow on effect from user and system interactions
                    - For behaviours that are specific to a page or component we would use what we call a mechanic test
                    - take the status it can be one of - loading, round in progress, round complete or error
                    - it is not practical to navigate through to a round just to test a different status
                    - specific tests around the round page would allow us to test the status component
                    - setup scenarios like a network timeout, the data base not being there
                    - writing these test first also makes sure that from the outset each page/component
                      is individually testable and you do not have to navigate through lots of screens
                      to come to a particular scenario
            </aside>
        </section>

        <section>
            <h3>Submit a guess <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-2.1-no-status.png" />
            </div>
            <aside class="notes" data-markdown>
                *Michael:
            </aside>
        </section>

        <section>
            <h3>Submit a guess <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-2.2-status-changes-loading-to-inprogress.gif" width="400" />
            </div>
            <pre><code data-trim>
                ...
                  API.fetchRoundData(round).then((data) => {
                    this.setState({status: 'IN-PROGRESS'})
                ...
                &lt;div className="images-container">
                  { this.state.status === 'LOADING ...' ?
                      <div className="background" /> :
                      this.state.images.map( ({id, src}) => (
                        <img key={id} src={src} alt="nice try"/>
                      ))
                  }
                </div>
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: set the status and display it
            </aside>
        </section>

        <section>
            <h3>Submit a guess <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape style="max-height: 600px">
                feature 'Game play lifecycle', js: true do
                  context 'the game terms are configured' do
                    before do
                      Term.create(phrase: 'tequila')
                    end

                    scenario 'WINNING a game' do
                      When 'user starts the game' do ... end

                      Then 'the game commences' do ... end

                      When 'the user submits an answer' do
                        <mark>focus_on(:game).fill_guess('tequila')</mark>
                      end

                      Then 'the user wins' do
                        pending
                        wait_for { focus_on(:game).status }.to eq('WINNER')
                      end
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: time to start guessing

                *Selena - pending.
                  - you might notice in this and some of the other tests there's line here - pending
                  - By marking a test as pending, all of the assertions made after the pending line will still be run
                    but one of them HAS to fail
                  - Two reason we might want to do this are
                      1. We haven't implemented the code to assert against - which is the case here
                      2. If you are working on master - like we do at Fresho - this enables us to
                         push code while features are still in progress
            </aside>
        </section>

        <section>
            <h3>Submit a guess <span class="failing-span">Failing test</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-2.3-no-input-field.png" />
            </div>
            <aside class="notes" data-markdown>
                *Michael:
            </aside>
        </section>

        <section>
            <h3>Submit a guess <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-2.4-input-correct-guess.gif" width="400" />
            </div>
            <pre><code data-trim>
                handleGuess(event) {
                  if(event.target.value.split(/[\s\n]/).find((word) => (word === this.state.term))) {
                    this.setState({status: 'WINNER'})
                  }
                }

                &lt;textarea
                  onChange={this.handleGuess }
                  value={this.state.guess}
                  disabled={this.state.status === 'WINNER'}&gt;&lt;/textarea>
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael: match the word and bind it to the text area
            </aside>
        </section>

        <section>
            <h3>Submit a guess <span class="iteration-span">Iteration 2</span></h3>
            <pre class="code-100"><code data-trim data-noescape style="max-height: 600px;">
                feature 'Game play lifecycle', js: true do
                  context 'the game terms are configured' do
                    before do
                      Term.create(phrase: 'tequila')
                    end

                    scenario 'WINNING a game' do
                      When 'user starts the game' do
                        visit('/')
                        wait_for {
                          focus_on(:welcome).text
                        }.to eq('Welcome to the Game')

                        focus_on(:welcome).start_game
                      end

                      Then 'the game commences' do
                        wait_for { focus_on(:game).round }.to eq('1')
                        wait_for {
                          focus_on(:game).status
                        }.to eq('IN-PROGRESS')
                        wait_for { focus_on(:game).images.count }.to eq(9)
                      end

                      When 'the user submits an answer' do
                        focus_on(:game).fill_guess('tequila')
                      end

                      Then 'the user wins' do
                        wait_for { focus_on(:game).status }.to eq('WINNER')
                      end
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael:
            </aside>
        </section>

        <section>
            <h3>Multi-round game <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'the user starts the next round' do
                  <mark>focus_on(:game).next_round</mark>
                end

                Then 'round two starts' do
                  pending
                  wait_for { focus_on(:game).round }.to eq('2')
                end
            </code></pre>
            <div class="iterative-testing">
                <img src="images/iteration-3.1-no-next-button.png" />
            </div>
            <aside class="notes" data-markdown>
                *Michael:
            </aside>
        </section>

        <section>
            <h3>Multi-round game <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-3.2-next-button-rendered.png" />
            </div>
            <pre><code data-trim data-noescape>
                &lt;Link to={`/round/${this.state.round + 1}`}>Next&lt;/Link>
            </code></pre>
            <aside class="notes" data-markdown>
                *Michael:
            </aside>
        </section>

        <section>
            <h3>Multi-round game <span class="failing-span">Failing test</span></h3>
            <pre><code data-trim data-noescape>
                When 'the user starts the next round' do
                  focus_on(:game).next_round
                end

                Then 'round two starts' do
                    <mark>wait_for { focus_on(:game).round }.to eq('2')</mark>
                end
            </code></pre>
            <div class="iterative-testing">
                <img src="images/iteration-3.2-next-button-rendered.png" />
            </div>
            <aside class="notes" data-markdown>

            </aside>
        </section>

        <section>
            <h3>Multi-round game <span class="passing-span">Make it pass</span></h3>
            <div class="iterative-testing">
                <img src="images/iteration-3.3-multi-round-game.gif" width="400" />
            </div>
            <aside class="notes" data-markdown>
                *Michael:
            </aside>
        </section>

        <section>
            <h3>Multi-round game <span class="iteration-span">Iteration 3</span></h3>
            <pre class="code-100"><code data-trim data-noescape style="max-height: 600px;">
                feature 'Game play lifecycle', js: true do
                  context 'the game terms are configured' do
                    before do
                      Term.create(phrase: 'tequila')
                    end

                    scenario 'WINNING a game' do
                      When 'user starts the game' do
                        visit('/')
                        wait_for {
                          focus_on(:welcome).text
                        }.to eq('Welcome to the Game')

                        focus_on(:welcome).start_game
                      end

                      Then 'the game commences' do
                        wait_for { focus_on(:game).round }.to eq('1')
                        wait_for { focus_on(:game).status }.to eq('IN-PROGRESS')
                        wait_for { focus_on(:game).timer }.to match(/[0-9]/)
                        wait_for { focus_on(:game).images.count }.to eq(9)
                      end

                      When 'the user submits an answer' do
                        focus_on(:game).fill_guess('tequila')
                      end

                      Then 'the user wins the round' do
                        wait_for { focus_on(:game).status }.to eq('WINNER')
                        wait_for { focus_on(:game).score }.to match(/[0-9]/)
                      end

                      When 'the user starts the next round' do
                        focus_on(:game).next_round
                      end

                      Then 'round two starts' do
                        wait_for { focus_on(:game).round }.to eq('2')
                      end
                    end
                  end
                end
            </code></pre>
            <aside class="notes" data-markdown>
                *Selena: Rinse and repeat.
                    There you go. 3 very basic iterations of tdd-ing a flow.
                    By stepping out the sequence of events that take place in this style of test, it's very easy to make
                    additions and adjustments to the way the app works.
                    We've only shown you a snippet of one flow that will take place in this app, which happens to go down a
                    happy path. There will in fact be a number of flows that emerge before this game is complete
            </aside>
        </section>
        <!-- 3 basic iterations building out the code -->

        <section>
            <h3>Let's play!</h3>
            <div>Just cause we built it, lets play a game!</div>

            <aside class="notes" data-markdown>
                *Selena: Aaaaand, just cause we built - let's play the game.
                         Who wants to play?!

                **Michael get ready to play the live game with the audience now**
            </aside>
        </section>

        <section>
          <iframe src="https://search-term.herokuapp.com" width="600" height="600"></iframe>
        </section>

        <section>
            <h3>The Unit</h3>
            TODO diagram whole system and the various sub systems that are the unit under test.
        </section>

        <section>
            <h3>Review</h3>
            <ul>
                <li class="fragment">Test first</li>
                <li class="fragment">Flow</li>
                <li class="fragment">Mechanic</li>
                <li class="fragment">Page Fragments</li>
                <li class="fragment">Flakes</li>
                <li class="fragment">Pending</li>
                <li class="fragment">Iterate</li>
            </ul>

            <aside class="notes" data-markdown>
                note: although this talk focused on flows, these points all apply to testing any unit at any level
                <!-- # TODO example: maybe talk over an isolated unit test of the round controller? -->
            </aside>
        </section>

        <section>
            <h3>Resources</h3>
                <p><a href="https://search-term.herokuapp.com/">https://search-term.herokuapp.com/</a></p>
                <p><a href="https://saramic.github.io/layered-testing-workshop/">https://saramic.github.io/layered-testing-workshop/</a></p>
            <div>
                <a href="http://twitter.com/intent/user?screen_name=selenasmall88">
                    <img class="twitter-avatar" src="images/avatar-selena.jpg" alt="selena-small"/>
                    <span>@selenasmall88</span>
                </a>
            </div>
            <div>
                <a href="http://twitter.com/intent/user?screen_name=saramic">
                    <img class="twitter-avatar" src="images/avatar-michael.jpg" alt="michael-milewski"/>
                    <span>@saramic</span>
                </a>
            </div>

            <aside class="notes" data-markdown>
                *Selena: If you think you can beat our high score, you can check out the app - it's hosted on heroku
                *Michael: And you can go back and look at the code we showed here on Github
                          Thanks everyone!
            </aside>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ],
    transition: 'none',
    history: true,
  });
</script>
</body>
</html>
